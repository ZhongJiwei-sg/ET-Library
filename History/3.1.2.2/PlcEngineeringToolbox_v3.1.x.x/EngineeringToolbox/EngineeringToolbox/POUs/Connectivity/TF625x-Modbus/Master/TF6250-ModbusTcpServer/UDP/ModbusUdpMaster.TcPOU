<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.5">
  <POU Name="ModbusUdpMaster" Id="{e85c5abd-3918-4b08-95f9-c4c66aa8cf36}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'no_check'}
// ModBus comunication master to multible slaves useing UDP protocol
// based on TF6250 - required lib: Tc2_ModbusTCP
FUNCTION_BLOCK ModbusUdpMaster
VAR CONSTANT
	MIN_SLAVE												:	INT := 1;
	MAX_SLAVE												:	INT := PARAM.MODBUS_MAX_SLAVES_OF_MASTER;
END_VAR
VAR_INPUT
	Enable													:	BOOL ; 		// FB will be processed as long as enable is TRUE 
	ResetTrig												:	BOOL ;		// The function block will be reset with a rising edge 
	SlaveCom												:	ARRAY[MIN_SLAVE..MAX_SLAVE] OF POINTER TO ModbusSlaveCom;
	Timestamp												:	DT;
END_VAR         	
VAR_OUTPUT      	
	Error													:	BOOL;		// Rising edge of Error informs that an error occurred during the execution of the Function Block 
{attribute 'displaymode':='hex'}
	ErrorID													:	UDINT;		// Error identification - see ADS return codes at Beckhoff infosys for further information 
	ErrorText												:	STRING;
END_VAR
VAR
(* memory **************************************************)
	state 													:	INT := 0;
	JobNo													:	INT := 0;
	SlaveNo													:	INT := 0;
(* trigger *************************************************)

(* timer ***************************************************)

(* blocks **************************************************)
	ReadCoils												:	FB_MBUdpReadCoils := (tTimeout		:= DEFAULT_ADS_TIMEOUT);		// Fnc 1
	ReadInputs												:	FB_MBUdpReadInputs := (tTimeout		:= DEFAULT_ADS_TIMEOUT);		// Fnc 2
	ReadRegs												:	FB_MBUdpReadRegs := (tTimeout		:= DEFAULT_ADS_TIMEOUT);		// Fnc 3
	ReadInputRegs											:	FB_MBUdpReadInputRegs := (tTimeout	:= DEFAULT_ADS_TIMEOUT);	// Fnc 4
	WriteSingleCoil											:	FB_MBUdpWriteSingleCoil := (tTimeout:= DEFAULT_ADS_TIMEOUT);// Fnc 5
	WriteSingleReg											:	FB_MBUdpWriteSingleReg := (tTimeout	:= DEFAULT_ADS_TIMEOUT);	// Fnc 6
	Diagnose												:	FB_MBUdpDiagnose := (tTimeout		:= DEFAULT_ADS_TIMEOUT);		// Fnc 8
	WriteCoils												:	FB_MBUdpWriteCoils := (tTimeout		:= DEFAULT_ADS_TIMEOUT);		// Fnc 15
	WriteRegs												:	FB_MBUdpWriteRegs := (tTimeout		:= DEFAULT_ADS_TIMEOUT);		// Fnc 16
	ReadWriteRegs											:	FB_MBUdpReadWriteRegs := (tTimeout	:= DEFAULT_ADS_TIMEOUT); 	// Fnc 23	use read and write job instead
(* internal used variables *********************************)
	i,j,k													:	INT :=0;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
	CASE state OF
	0:	(* Idle *)
		IF Enable 
		THEN
			k 												:=	0;
			JobNo  :=  SlaveNo								:=	1;
			state 											:=	10;
		END_IF

	10: 
		IF GetNextSlave() 
		THEN (* find Slave *)
			k 												:= 0;
			IF GetNextJob() 
			THEN (* find JobNo *)
				SlaveCom[SlaveNo]^.currentJobIdx 			:= JobNo;
				SlaveCom[SlaveNo]^.writeJobRequested 		:= SlaveCom[SlaveNo]^.Jobs[JobNo].FunctionCode >= 5;
				State 										:= SEL(SlaveCom[SlaveNo]^.writeJobRequested, 20, 15);
			END_IF
		ELSE
			state 											:=	0;
		END_IF
	
	15: (* wait for valid write date *)
		IF NOT SlaveCom[SlaveNo]^.writeJobRequested
		THEN
			SlaveCom[SlaveNo]^.Jobs[JobNo].Valid 			:= FALSE;
			state 											:= 20;
		END_IF

	20: (* start job *)	
		IF NOT StartJob(FALSE) // Busy
		THEN						
			state 											:= 30;
		END_IF

	30: (* wait for com cycle *)
		IF NOT StartJob(TRUE) THEN // Busy
			IF Error 
			THEN
				ErrorText									:= CONCAT('Error at SlaveNo: ',	CONCAT(INT_TO_STRING(SlaveNo), CONCAT(', JobNo: ', INT_TO_STRING(JobNo))));
				SlaveCom[SlaveNo]^.countBad 				:= SlaveCom[SlaveNo]^.countBad +1;
				state 										:= 98; 
			ELSE
				SlaveCom[SlaveNo]^.countGood 				:= SlaveCom[SlaveNo]^.countGood +1;
				SlaveCom[SlaveNo]^.Jobs[JobNo].Valid 		:= TRUE;
				SlaveCom[SlaveNo]^.Jobs[JobNo].TimeStamp 	:= Timestamp;
				JobNo 										:= JobNo + 1;
				state 										:= 10;	(* next job *)
			END_IF
			StartJob(FALSE);
		END_IF

	98: (* wait for quit *)
		IF ResetTrig THEN
			reset();
		END_IF

	END_CASE]]></ST>
    </Implementation>
    <Method Name="getNextJob" Id="{9dd553c0-e69a-4bf1-b54e-b621b983c9d8}">
      <Declaration><![CDATA[METHOD PRIVATE getNextJob : Bool //Return value = TRUE if execution finished
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[	
	WHILE SlaveCom[SlaveNo]^.Jobs[JobNo].FunctionCode = 0 DO
		JobNo 											:= JobNo + 1;
		IF JobNo > SlaveCom[SlaveNo]^.MAX_SLAVE_JOB THEN
			JobNo 										:= SlaveCom[SlaveNo]^.MIN_SLAVE_JOB;
			SlaveNo 									:= SlaveNo + 1;
			GetNextJob									:= FALSE;
			RETURN;
		END_IF
	END_WHILE
	GetNextJob											:= TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="getNextSlave" Id="{6d01a8fb-857d-4430-8ebe-7f1687d34ced}">
      <Declaration><![CDATA[METHOD PRIVATE getNextSlave : Bool //Return value = TRUE if execution finished
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[	WHILE SlaveCom[SlaveNo] = 0 or_else not SlaveCom[SlaveNo]^.Enable DO
		SlaveNo 										:= SlaveNo + 1;
		IF SlaveNo > MAX_SLAVE 
		THEN
			k 											:= k + 1;
			SlaveNo 									:= MIN_SLAVE;
		ELSIF k = 2 
		THEN
			k 											:= 0;
			GetNextSlave								:= FALSE;
			RETURN;
		END_IF	
	END_WHILE
	GetNextSlave										:= TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="reset" Id="{1d523c50-92df-4b4e-9e2a-37fe97d52e21}">
      <Declaration><![CDATA[METHOD PUBLIC reset : booL //Return value = TRUE if execution finished
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF State = 98 
THEN
	Error													:= FALSE;
	ErrorID													:= 0;
	ErrorText												:= '';
	state													:= 0;
END_IF	
reset														:= TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="startJob" Id="{db8eb6f4-090b-4aa8-aeff-11b85b8008a4}">
      <Declaration><![CDATA[METHOD PRIVATE startJob : BOOL //Return value = TRUE if busy - TRUE as long as the job is busy
VAR_INPUT
	Execute							: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[	IF 	SlaveCom[SlaveNo]^.Jobs[JobNo].FunctionCode = 1 THEN
		ReadCoils(
			sIPAddr			:= SlaveCom[SlaveNo]^.ipAddr, 
			nTCPPort		:= TO_UINT(SlaveCom[SlaveNo]^.Port), 
			nUnitID			:= SlaveCom[SlaveNo]^.Address, 
			nQuantity		:= SlaveCom[SlaveNo]^.jobs[JobNo].Quantity, 
			nMBAddr			:= SlaveCom[SlaveNo]^.jobs[JobNo].startAddress, 
			cbLength		:= SlaveCom[SlaveNo]^.jobs[JobNo].Quantity, 
			pDestAddr		:= ADR(SlaveCom[SlaveNo]^.Data), 
			bExecute		:= Execute, 
			tTimeout		:= , 
			bBusy			=> StartJob, 
			bError			=> Error, 
			nErrId			=> ErrorID);
		
	ELSIF 	SlaveCom[SlaveNo]^.Jobs[JobNo].FunctionCode = 2 THEN
		ReadInputs(
			sIPAddr			:= SlaveCom[SlaveNo]^.ipAddr, 
			nTCPPort		:= TO_UINT(SlaveCom[SlaveNo]^.Port), 
			nUnitID			:= SlaveCom[SlaveNo]^.Address, 
			nQuantity		:= SlaveCom[SlaveNo]^.jobs[JobNo].Quantity, 
			nMBAddr			:= SlaveCom[SlaveNo]^.jobs[JobNo].startAddress, 
			cbLength		:= SlaveCom[SlaveNo]^.jobs[JobNo].Quantity, 
			pDestAddr		:= ADR(SlaveCom[SlaveNo]^.Data), 
			bExecute		:= Execute, 
			tTimeout		:= , 
			bBusy			=> StartJob, 
			bError			=> Error, 
			nErrId			=> ErrorID);
			
	ELSIF 	SlaveCom[SlaveNo]^.Jobs[JobNo].FunctionCode = 3 THEN
		ReadRegs(
			sIPAddr			:= SlaveCom[SlaveNo]^.ipAddr, 
			nTCPPort		:= TO_UINT(SlaveCom[SlaveNo]^.Port), 
			nUnitID			:= SlaveCom[SlaveNo]^.Address, 
			nQuantity		:= SlaveCom[SlaveNo]^.jobs[JobNo].Quantity, 
			nMBAddr			:= SlaveCom[SlaveNo]^.jobs[JobNo].startAddress, 
			cbLength		:= SlaveCom[SlaveNo]^.jobs[JobNo].Quantity * 2, 
			pDestAddr		:= ADR(SlaveCom[SlaveNo]^.Data), 
			bExecute		:= Execute, 
			tTimeout		:= DEFAULT_ADS_TIMEOUT, 
			bBusy			=> StartJob, 
			bError			=> Error, 
			nErrId			=> ErrorID);
	
	ELSIF 	SlaveCom[SlaveNo]^.Jobs[JobNo].FunctionCode = 4 THEN
		ReadInputRegs(
			sIPAddr			:= SlaveCom[SlaveNo]^.ipAddr, 
			nTCPPort		:= TO_UINT(SlaveCom[SlaveNo]^.Port), 
			nUnitID			:= SlaveCom[SlaveNo]^.Address, 
			nQuantity		:= SlaveCom[SlaveNo]^.jobs[JobNo].Quantity, 
			nMBAddr			:= SlaveCom[SlaveNo]^.jobs[JobNo].startAddress, 
			cbLength		:= SlaveCom[SlaveNo]^.jobs[JobNo].Quantity * 2, 
			pDestAddr		:= ADR(SlaveCom[SlaveNo]^.Data), 
			bExecute		:= Execute, 
			tTimeout		:= , 
			bBusy			=> StartJob, 
			bError			=> Error, 
			nErrId			=> ErrorID);
	
	ELSIF 	SlaveCom[SlaveNo]^.Jobs[JobNo].FunctionCode = 5 THEN
		WriteSingleCoil(
			sIPAddr			:= SlaveCom[SlaveNo]^.ipAddr, 
			nTCPPort		:= TO_UINT(SlaveCom[SlaveNo]^.Port), 
			nUnitID			:= SlaveCom[SlaveNo]^.Address, 
			nMBAddr			:= SlaveCom[SlaveNo]^.jobs[JobNo].startAddress, 
			nValue			:= SlaveCom[SlaveNo]^.data[1], 
			bExecute		:= Execute, 
			tTimeout		:= , 
			bBusy			=> StartJob, 
			bError			=> Error, 
			nErrId			=> ErrorID);
	
	ELSIF 	SlaveCom[SlaveNo]^.Jobs[JobNo].FunctionCode = 6 THEN
		WriteSingleReg(
			sIPAddr			:= SlaveCom[SlaveNo]^.ipAddr, 
			nTCPPort		:= TO_UINT(SlaveCom[SlaveNo]^.Port), 
			nUnitID			:= SlaveCom[SlaveNo]^.Address, 
			nMBAddr			:= SlaveCom[SlaveNo]^.jobs[JobNo].startAddress, 
			nValue			:= SlaveCom[SlaveNo]^.data[1], 
			bExecute		:= Execute, 
			tTimeout		:= , 
			bBusy			=> StartJob, 
			bError			=> Error, 
			nErrId			=> ErrorID);
			
	ELSIF 	SlaveCom[SlaveNo]^.Jobs[JobNo].FunctionCode = 8 THEN
		Diagnose(
			sIPAddr			:= SlaveCom[SlaveNo]^.ipAddr, 
			nTCPPort		:= TO_UINT(SlaveCom[SlaveNo]^.Port), 
			nUnitID			:= SlaveCom[SlaveNo]^.Address, 
			bExecute		:= Execute, 
			tTimeout		:= , 
			bBusy			=> StartJob, 
			bError			=> Error, 
			nErrId			=> ErrorID);	
			
	ELSIF 	SlaveCom[SlaveNo]^.Jobs[JobNo].FunctionCode = 15 THEN
		WriteCoils(
			sIPAddr			:= SlaveCom[SlaveNo]^.ipAddr, 
			nTCPPort		:= TO_UINT(SlaveCom[SlaveNo]^.Port), 
			nUnitID			:= SlaveCom[SlaveNo]^.Address, 
			nQuantity		:= SlaveCom[SlaveNo]^.jobs[JobNo].Quantity, 
			nMBAddr			:= SlaveCom[SlaveNo]^.jobs[JobNo].startAddress, 
			cbLength		:= SlaveCom[SlaveNo]^.jobs[JobNo].Quantity, 
			pSrcAddr		:= ADR(SlaveCom[SlaveNo]^.Data), 
			bExecute		:= Execute, 
			tTimeout		:= , 
			bBusy			=> StartJob, 
			bError			=> Error, 
			nErrId			=> ErrorID);
	
	ELSIF 	SlaveCom[SlaveNo]^.Jobs[JobNo].FunctionCode = 16 THEN
		WriteRegs(
			sIPAddr			:= SlaveCom[SlaveNo]^.ipAddr, 
			nTCPPort		:= TO_UINT(SlaveCom[SlaveNo]^.Port), 
			nUnitID			:= SlaveCom[SlaveNo]^.Address, 
			nQuantity		:= SlaveCom[SlaveNo]^.jobs[JobNo].Quantity, 
			nMBAddr			:= SlaveCom[SlaveNo]^.jobs[JobNo].startAddress, 
			cbLength		:= SlaveCom[SlaveNo]^.jobs[JobNo].Quantity, 
			pSrcAddr		:= ADR(SlaveCom[SlaveNo]^.Data), 
			bExecute		:= Execute, 
			tTimeout		:= , 
			bBusy			=> StartJob, 
			bError			=> Error, 
			nErrId			=> ErrorID);
			
	ELSIF 	SlaveCom[SlaveNo]^.Jobs[JobNo].FunctionCode = 23 THEN
		// not implemented
(*		ReadWriteRegs(
			sIPAddr			:= SlaveCom[SlaveNo]^.ipAddr, 
			nTCPPort		:= SlaveCom[SlaveNo]^.Port, 
			nUnitID			:= SlaveCom[SlaveNo]^.Address, 
			nReadQuantity	:= SlaveCom[SlaveNo]^.jobs[JobNo].Quantity, 
			nMBReadAddr		:= SlaveCom[SlaveNo]^.jobs[JobNo].startAddress, 
			nWriteQuantity	:= , // missing
			nMBWriteAddr	:= , // missing
			cbDestLength	:= SlaveCom[SlaveNo]^.jobs[JobNo].Quantity, 
			pDestAddr		:= ADR(SlaveCom[SlaveNo]^.Data),
			cbSrcLength		:= , // missing
			pSrcAddr 		:= , // missing
			bExecute		:= Execute, 
			tTimeout		:= , 
			bBusy			=> StartJob, 
			bError			=> Error, 
			nErrId			=> ErrorID);	

*)			
	END_IF]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="ModbusUdpMaster">
      <LineId Id="205" Count="58" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="ModbusUdpMaster.getNextJob">
      <LineId Id="3" Count="9" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="ModbusUdpMaster.getNextSlave">
      <LineId Id="3" Count="12" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="ModbusUdpMaster.reset">
      <LineId Id="3" Count="5" />
      <LineId Id="2" Count="0" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="ModbusUdpMaster.startJob">
      <LineId Id="3" Count="147" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>